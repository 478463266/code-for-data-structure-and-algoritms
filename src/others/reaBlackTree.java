package others;

/*
ref:https://www.cnblogs.com/LiaHon/p/11203229.html
https://www.jianshu.com/p/e136ec79235c
https://en.wikipedia.org/wiki/Red%E2%80%93black_tree
https://www.jianshu.com/p/e136ec79235c
https://www.cnblogs.com/skywang12345/p/3245399.html#a34

规则：
    节点分为红色或者黑色；
    根节点必为黑色；
    叶子节点都为黑色，且为null；
    连接红色节点的两个子节点都为黑色（红黑树不会出现相邻的红色节点）；
    从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点；
    新加入到红黑树的节点为红色节点；

隐藏规则：
    1）从根节点到叶子节点的最长路径不大于最短路径的2倍（平衡性的保证）
        怎么样的路径算最短路径？，从规则5中，我们知道从根节点到每个叶子节点的黑色节点数量是一样的，那么纯由黑色节点组成的路径就是最短路径；
        什么样的路径算是最长路径？根据规则4和规则3，若有红色节点，则必然有一个连接的黑色节点，当红色节点和黑色节点数量相同时，就是最长路径，也就是黑色节点（或红色节点）* 2
    2）为什么说新加入到红黑树中的节点为红色节点
    从规则4中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的黑色节点的话，必然破坏规则，但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些。

平衡方式
    维持平衡主要通过两种方式【变色】和【旋转】，【旋转】又分【左旋】和【右旋】，两种方式可相互结合。

insert:
    找到位置-红色-调整（五种情况）：插入节点为根节点；父亲为黑；父亲为红且叔叔有红；父亲为红且叔叔为黑或者没有叔叔（父亲是祖父的左孩子，插入点是父亲的左孩子；父亲是左孩子，插入点是右孩子）；与之对应的右边情况

删除：
    删除操作首先要确定待删除节点有几个孩子，如果有两个孩子，不能直接删除该节点。而是要先找到该节点的前驱（该节点左子树中最大的节点）或者后继（
该节点右子树中最小的节点），然后将前驱或者后继的值复制到要删除的节点中，最后再将前驱或后继删除。由于前驱和后继至多只有一个孩子节点，
这样我们就把原来要删除的节点有两个孩子的问题转化为只有一个孩子节点的问题，问题被简化了一些。
    红黑树删除操作的复杂度在于删除节点的颜色，当删除的节点是红色时，直接拿其孩子节点补空位即可。因为删除红色节点，性质5（从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点）仍能够被满足。
当删除的节点是黑色时，那么所有经过该节点的路径上的黑节点数量少了一个，破坏了性质5。如果该节点的孩子为红色，直接拿孩子节点替换被删除的节点，并将孩子节点染成黑色，即可恢复性质5。
步骤：
    删除的是根节点，则直接将根节点置为null;
    待删除节点的左右子节点都为null，删除时将该节点置为null;
    待删除节点的左右子节点有一个有值，则用有值的节点替换该节点即可；
    待删除节点的左右子节点都不为null，则找前驱或者后继，将前驱或者后继的值复制到该节点中，然后删除前驱或者后继；
    节点删除后可能会造成红黑树的不平衡，这时我们需通过【变色】+【旋转】的方式来调整，使之平衡，上面也给出了例子，建议大家多多练习，而不必背下来。
更好的总结：
第一步：将红黑树当作一颗二叉查找树，将节点删除。
       这和"删除常规二叉查找树中删除节点的方法是一样的"。分3种情况：
       ① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。
       ② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。
       ③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。这样就巧妙的将问题转换为"删除后继节点"的情况了，下面就考虑后继节点。 在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然"的后继节点"不可能双子都非空，就意味着"该节点的后继节点"要么没有儿子，要么只有一个儿子。若没有儿子，则按"情况① "进行处理；若只有一个儿子，则按"情况② "进行处理。
第二步：通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。
       因为"第一步"中删除节点之后，可能会违背红黑树的特性。所以需要通过"旋转和重新着色"来修正该树，使之重新成为一棵红黑树。
 */


public class reaBlackTree {
}
